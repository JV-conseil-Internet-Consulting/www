"use strict";
(self["webpackChunkdeepdive"] = self["webpackChunkdeepdive"] || []).push([["search"],{

/***/ "./_js/src/search.js":
/*!***************************!*\
  !*** ./_js/src/search.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/tap.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js");
/* harmony import */ var lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/html.js */ "./node_modules/lit/html.js");
/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directives/repeat.js */ "./node_modules/lit/directives/repeat.js");
/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directives/if-defined.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common */ "./_js/src/common.js");
var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) 2023 JV conseil <https://www.jv-conseil.net/>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// import { join } from 'path';




// import { render, html } from 'lit-html';
// import { repeat } from 'lit-html/directives/repeat';
// import { ifDefined } from 'lit-html/directives/if-defined';





var SEL_NAVBAR_BTN_BAR = '#_navbar > .content > .nav-btn-bar';
var relativeUrl = url => url.startsWith(window._baseURL) ? url : join(window._baseURL, url);
var smartUrl = url => url.includes('://') ? url : relativeUrl(url);
var calcSrcSet = srcset => !srcset ? undefined : Object.entries(srcset).map(_ref => {
  var [desc, url] = _ref;
  return "".concat(smartUrl(url), " ").concat(desc);
}).join(',');
_asyncToGenerator(function* () {
  var _document$getElementB;
  yield _common__WEBPACK_IMPORTED_MODULE_3__.stylesheetReady;
  var pushStateEl = document.getElementById('_pushState');
  var searchFrag = (0,_common__WEBPACK_IMPORTED_MODULE_3__.importTemplate)('_search-template');
  var workerHref = (_document$getElementB = document.getElementById('_hrefSearch')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.href;
  if (searchFrag && workerHref) {
    var navbarEl = document.querySelector(SEL_NAVBAR_BTN_BAR);
    var [searchBtnEl, searchBoxEl, hitsEl] = searchFrag.children;
    if (!searchBtnEl || !searchBoxEl || !hitsEl || !navbarEl) return;
    navbarEl.insertBefore(searchBtnEl, navbarEl.querySelector('.nav-span'));
    navbarEl.insertBefore(searchBoxEl, navbarEl.querySelector('.nav-span'));
    navbarEl.insertBefore(hitsEl, navbarEl.querySelector('.nav-span'));
    var searchInputEl = searchBoxEl.querySelector('input[type=search]');
    var searchCloseEl = searchBoxEl.querySelector('button[type=reset]');
    if (!searchInputEl || !searchCloseEl) return;
    searchBtnEl.addEventListener('click', () => {
      searchInputEl.focus();
    });
    searchInputEl.addEventListener('focus', () => {
      searchInputEl.select();
      searchBoxEl.classList.add('show');
      if (searchInputEl.value !== '') hitsEl.style.display = '';
    });
    var closeHandler = () => {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.blur();
      searchBoxEl.classList.remove('show');
      hitsEl.style.display = 'none';
    };
    hitsEl.style.display = 'none';
    searchCloseEl.addEventListener('click', closeHandler);
    pushStateEl === null || pushStateEl === void 0 ? void 0 : pushStateEl.addEventListener('hy-push-state-start', closeHandler);

    // Load search worker after user interaction
    yield (0,_common__WEBPACK_IMPORTED_MODULE_3__.once)(document, 'click');

    /**
     * Module parse failed: ParserHelpers.addParsedVariableToModule is not a function
     * See <https://github.com/GoogleChromeLabs/worker-plugin/issues/88#issuecomment-702358203>
     * const worker = new Worker('./search.worker.js', { type: 'module' });
     */
    // const worker = new Worker(new URL('./search.worker.js', { type: 'module' }));
    // const worker = new Worker(new URL('./search.worker.js', import.meta.url));
    var worker = new Worker( /* webpackChunkName: "search-worker" */new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("search-worker"), __webpack_require__.b));
    (0,_common__WEBPACK_IMPORTED_MODULE_3__.postMessage)(worker, window._search);
    var prevVal = '';
    (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.fromEvent)(searchInputEl, 'keyup').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.tap)(e => {
      if (e.target.value === '' && prevVal === '' && e.keyCode === 27) {
        e.preventDefault();
        closeHandler();
      }
      prevVal = e.target.value;
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.switchMap)(e => (0,_common__WEBPACK_IMPORTED_MODULE_3__.postMessage)(worker, e.target.value)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.tap)(items => {
      if (items.length) {
        (0,lit_html_js__WEBPACK_IMPORTED_MODULE_0__.render)((0,lit_html_js__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n                <ul>\n                  ", "\n                </ul>\n              "])), (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_1__.repeat)(items, item => item.url, item => (0,lit_html_js__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n                      <li class=\"search-item\" @click=", ">\n                        <div class=\"search-img aspect-ratio sixteen-ten\">\n                          ", "\n                        </div>\n                        <div class=\"search-text\">\n                          <p>\n                            <a class=\"heading\" href=", " tabindex=\"1\">", "</a>\n                            <small>", "</small>\n                          </p>\n                          ", "\n                        </div>\n                      </li>\n                    "])), () => {
          var _pushStateEl$assign;
          return pushStateEl === null || pushStateEl === void 0 ? void 0 : (_pushStateEl$assign = pushStateEl.assign) === null || _pushStateEl$assign === void 0 ? void 0 : _pushStateEl$assign.call(pushStateEl, item.url);
        }, !item.image ? null : (0,lit_html_js__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<img\n                                src=\"", "\"\n                                srcset=\"", "\"\n                                sizes=\"4.67rem\"\n                              />"])), smartUrl(item.image.src || item.image.path || item.image), (0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_2__.ifDefined)(calcSrcSet(item.image.srcset))), relativeUrl(item.url), item.title, item.url, item.description ? (0,lit_html_js__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([" <p>", "</p> "])), item.description) : ''))), hitsEl);
        hitsEl.style.display = '';
      } else {
        hitsEl.style.display = 'none';
      }
    })).subscribe();
  }
})();

/***/ }),

/***/ "./node_modules/lit-html/directives/if-defined.js":
/*!********************************************************!*\
  !*** ./node_modules/lit-html/directives/if-defined.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ifDefined": () => (/* binding */ ifDefined)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/lit-html.js");
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

var previousValues = new WeakMap();
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
var ifDefined = (0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.directive)(value => part => {
  var previousValue = previousValues.get(part);
  if (value === undefined && part instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.AttributePart) {
    // If the value is undefined, remove the attribute, but only if the value
    // was previously defined.
    if (previousValue !== undefined || !previousValues.has(part)) {
      var name = part.committer.name;
      part.committer.element.removeAttribute(name);
    }
  } else if (value !== previousValue) {
    part.setValue(value);
  }
  previousValues.set(part, value);
});

/***/ }),

/***/ "./node_modules/lit-html/directives/repeat.js":
/*!****************************************************!*\
  !*** ./node_modules/lit-html/directives/repeat.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "repeat": () => (/* binding */ repeat)
/* harmony export */ });
/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ "./node_modules/lit-html/lit-html.js");
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Helper functions for manipulating parts
// TODO(kschaaf): Refactor into Part API?
var createAndInsertPart = (containerPart, beforePart) => {
  var container = containerPart.startNode.parentNode;
  var beforeNode = beforePart === undefined ? containerPart.endNode : beforePart.startNode;
  var startNode = container.insertBefore((0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.createMarker)(), beforeNode);
  container.insertBefore((0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.createMarker)(), beforeNode);
  var newPart = new _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.NodePart(containerPart.options);
  newPart.insertAfterNode(startNode);
  return newPart;
};
var updatePart = (part, value) => {
  part.setValue(value);
  part.commit();
  return part;
};
var insertPartBefore = (containerPart, part, ref) => {
  var container = containerPart.startNode.parentNode;
  var beforeNode = ref ? ref.startNode : containerPart.endNode;
  var endNode = part.endNode.nextSibling;
  if (endNode !== beforeNode) {
    (0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.reparentNodes)(container, part.startNode, endNode, beforeNode);
  }
};
var removePart = part => {
  (0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.removeNodes)(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
};
// Helper for generating a map of array item to its index over a subset
// of an array (used to lazily generate `newKeyToIndexMap` and
// `oldKeyToIndexMap`)
var generateMap = (list, start, end) => {
  var map = new Map();
  for (var i = start; i <= end; i++) {
    map.set(list[i], i);
  }
  return map;
};
// Stores previous ordered list of parts and map of key to index
var partListCache = new WeakMap();
var keyListCache = new WeakMap();
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
var repeat = (0,_lit_html_js__WEBPACK_IMPORTED_MODULE_0__.directive)((items, keyFnOrTemplate, template) => {
  var keyFn;
  if (template === undefined) {
    template = keyFnOrTemplate;
  } else if (keyFnOrTemplate !== undefined) {
    keyFn = keyFnOrTemplate;
  }
  return containerPart => {
    if (!(containerPart instanceof _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.NodePart)) {
      throw new Error('repeat can only be used in text bindings');
    }
    // Old part & key lists are retrieved from the last update
    // (associated with the part for this instance of the directive)
    var oldParts = partListCache.get(containerPart) || [];
    var oldKeys = keyListCache.get(containerPart) || [];
    // New part list will be built up as we go (either reused from
    // old parts or created for new keys in this update). This is
    // saved in the above cache at the end of the update.
    var newParts = [];
    // New value list is eagerly generated from items along with a
    // parallel array indicating its key.
    var newValues = [];
    var newKeys = [];
    var index = 0;
    for (var item of items) {
      newKeys[index] = keyFn ? keyFn(item, index) : index;
      newValues[index] = template(item, index);
      index++;
    }
    // Maps from key to index for current and previous update; these
    // are generated lazily only when needed as a performance
    // optimization, since they are only required for multiple
    // non-contiguous changes in the list, which are less common.
    var newKeyToIndexMap;
    var oldKeyToIndexMap;
    // Head and tail pointers to old parts and new values
    var oldHead = 0;
    var oldTail = oldParts.length - 1;
    var newHead = 0;
    var newTail = newValues.length - 1;
    // Overview of O(n) reconciliation algorithm (general approach
    // based on ideas found in ivi, vue, snabbdom, etc.):
    //
    // * We start with the list of old parts and new values (and
    //   arrays of their respective keys), head/tail pointers into
    //   each, and we build up the new list of parts by updating
    //   (and when needed, moving) old parts or creating new ones.
    //   The initial scenario might look like this (for brevity of
    //   the diagrams, the numbers in the array reflect keys
    //   associated with the old parts or new values, although keys
    //   and parts/values are actually stored in parallel arrays
    //   indexed using the same head/tail pointers):
    //
    //      oldHead v                 v oldTail
    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
    //   newParts: [ ,  ,  ,  ,  ,  ,  ]
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
    //                                      item order
    //      newHead ^                 ^ newTail
    //
    // * Iterate old & new lists from both sides, updating,
    //   swapping, or removing parts at the head/tail locations
    //   until neither head nor tail can move.
    //
    // * Example below: keys at head pointers match, so update old
    //   part 0 in-place (no need to move it) and record part 0 in
    //   the `newParts` list. The last thing we do is advance the
    //   `oldHead` and `newHead` pointers (will be reflected in the
    //   next diagram).
    //
    //      oldHead v                 v oldTail
    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
    //                                      & newHead
    //      newHead ^                 ^ newTail
    //
    // * Example below: head pointers don't match, but tail
    //   pointers do, so update part 6 in place (no need to move
    //   it), and record part 6 in the `newParts` list. Last,
    //   advance the `oldTail` and `oldHead` pointers.
    //
    //         oldHead v              v oldTail
    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
    //                                      & newTail
    //         newHead ^              ^ newTail
    //
    // * If neither head nor tail match; next check if one of the
    //   old head/tail items was removed. We first need to generate
    //   the reverse map of new keys to index (`newKeyToIndexMap`),
    //   which is done once lazily as a performance optimization,
    //   since we only hit this case if multiple non-contiguous
    //   changes were made. Note that for contiguous removal
    //   anywhere in the list, the head and tails would advance
    //   from either end and pass each other before we get to this
    //   case and removals would be handled in the final while loop
    //   without needing to generate the map.
    //
    // * Example below: The key at `oldTail` was removed (no longer
    //   in the `newKeyToIndexMap`), so remove that part from the
    //   DOM and advance just the `oldTail` pointer.
    //
    //         oldHead v           v oldTail
    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
    //         newHead ^           ^ newTail
    //
    // * Once head and tail cannot move, any mismatches are due to
    //   either new or moved items; if a new key is in the previous
    //   "old key to old index" map, move the old part to the new
    //   location, otherwise create and insert a new part. Note
    //   that when moving an old part we null its position in the
    //   oldParts array if it lies between the head and tail so we
    //   know to skip it when the pointers get there.
    //
    // * Example below: neither head nor tail match, and neither
    //   were removed; so find the `newHead` key in the
    //   `oldKeyToIndexMap`, and move that old part's DOM into the
    //   next head position (before `oldParts[oldHead]`). Last,
    //   null the part in the `oldPart` array since it was
    //   somewhere in the remaining oldParts still to be scanned
    //   (between the head and tail pointers) so that we know to
    //   skip that old part on future iterations.
    //
    //         oldHead v        v oldTail
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
    //                                      newHead
    //         newHead ^           ^ newTail
    //
    // * Note that for moves/insertions like the one above, a part
    //   inserted at the head pointer is inserted before the
    //   current `oldParts[oldHead]`, and a part inserted at the
    //   tail pointer is inserted before `newParts[newTail+1]`. The
    //   seeming asymmetry lies in the fact that new parts are
    //   moved into place outside in, so to the right of the head
    //   pointer are old parts, and to the right of the tail
    //   pointer are new parts.
    //
    // * We always restart back from the top of the algorithm,
    //   allowing matching and simple updates in place to
    //   continue...
    //
    // * Example below: the head pointers once again match, so
    //   simply update part 1 and record it in the `newParts`
    //   array.  Last, advance both head pointers.
    //
    //         oldHead v        v oldTail
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
    //                                      & newHead
    //            newHead ^        ^ newTail
    //
    // * As mentioned above, items that were moved as a result of
    //   being stuck (the final else clause in the code below) are
    //   marked with null, so we always advance old pointers over
    //   these so we're comparing the next actual old value on
    //   either end.
    //
    // * Example below: `oldHead` is null (already placed in
    //   newParts), so advance `oldHead`.
    //
    //            oldHead v     v oldTail
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
    //               newHead ^     ^ newTail
    //
    // * Note it's not critical to mark old parts as null when they
    //   are moved from head to tail or tail to head, since they
    //   will be outside the pointer range and never visited again.
    //
    // * Example below: Here the old tail key matches the new head
    //   key, so the part at the `oldTail` position and move its
    //   DOM to the new head position (before `oldParts[oldHead]`).
    //   Last, advance `oldTail` and `newHead` pointers.
    //
    //               oldHead v  v oldTail
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
    //                                     advance oldTail & newHead
    //               newHead ^     ^ newTail
    //
    // * Example below: Old and new head keys match, so update the
    //   old head part in place, and advance the `oldHead` and
    //   `newHead` pointers.
    //
    //               oldHead v oldTail
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
    //                                      newHead
    //                  newHead ^  ^ newTail
    //
    // * Once the new or old pointers move past each other then all
    //   we have left is additions (if old list exhausted) or
    //   removals (if new list exhausted). Those are handled in the
    //   final while loops at the end.
    //
    // * Example below: `oldHead` exceeded `oldTail`, so we're done
    //   with the main loop.  Create the remaining part and insert
    //   it at the new head position, and the update is complete.
    //
    //                   (oldHead > oldTail)
    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
    //                     newHead ^ newTail
    //
    // * Note that the order of the if/else clauses is not
    //   important to the algorithm, as long as the null checks
    //   come first (to ensure we're always working on valid old
    //   parts) and that the final else clause comes last (since
    //   that's where the expensive moves occur). The order of
    //   remaining clauses is is just a simple guess at which cases
    //   will be most common.
    //
    // * TODO(kschaaf) Note, we could calculate the longest
    //   increasing subsequence (LIS) of old items in new position,
    //   and only move those not in the LIS set. However that costs
    //   O(nlogn) time and adds a bit more code, and only helps
    //   make rare types of mutations require fewer moves. The
    //   above handles removes, adds, reversal, swaps, and single
    //   moves of contiguous items in linear time, in the minimum
    //   number of moves. As the number of multiple moves where LIS
    //   might help approaches a random shuffle, the LIS
    //   optimization becomes less helpful, so it seems not worth
    //   the code at this point. Could reconsider if a compelling
    //   case arises.
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        // `null` means old part at head has already been used
        // below; skip
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        // `null` means old part at tail has already been used
        // below; skip
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        // Old head matches new head; update in place
        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        // Old tail matches new tail; update in place
        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        // Old head matches new tail; update and move to new tail
        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);
        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        // Old tail matches new head; update and move to new head
        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);
        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === undefined) {
          // Lazily generate key-to-index maps, used for removals &
          // moves below
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          // Old head is no longer in new list; remove
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          // Old tail is no longer in new list; remove
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          // Any mismatches at this point are due to additions or
          // moves; see if we have an old part we can reuse and move
          // into place
          var oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          var oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            // No old part for this value; create a new one and
            // insert it
            var newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
            updatePart(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            // Reuse old part
            newParts[newHead] = updatePart(oldPart, newValues[newHead]);
            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
            // This marks the old part as having been used, so that
            // it will be skipped in the first two checks above
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    // Add parts for any remaining new values
    while (newHead <= newTail) {
      // For all remaining additions, we insert before last new
      // tail, since old pointers are no longer valid
      var _newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
      updatePart(_newPart, newValues[newHead]);
      newParts[newHead++] = _newPart;
    }
    // Remove any remaining unused old parts
    while (oldHead <= oldTail) {
      var _oldPart = oldParts[oldHead++];
      if (_oldPart !== null) {
        removePart(_oldPart);
      }
    }
    // Save order of new parts for next round
    partListCache.set(containerPart, newParts);
    keyListCache.set(containerPart, newKeys);
  };
});

/***/ }),

/***/ "./node_modules/lit/directives/if-defined.js":
/*!***************************************************!*\
  !*** ./node_modules/lit/directives/if-defined.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ifDefined": () => (/* reexport safe */ lit_html_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_0__.ifDefined)
/* harmony export */ });
/* harmony import */ var lit_html_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/if-defined.js */ "./node_modules/lit-html/directives/if-defined.js");


/***/ }),

/***/ "./node_modules/lit/directives/repeat.js":
/*!***********************************************!*\
  !*** ./node_modules/lit/directives/repeat.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "repeat": () => (/* reexport safe */ lit_html_directives_repeat_js__WEBPACK_IMPORTED_MODULE_0__.repeat)
/* harmony export */ });
/* harmony import */ var lit_html_directives_repeat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/repeat.js */ "./node_modules/lit-html/directives/repeat.js");


/***/ }),

/***/ "./node_modules/lit/html.js":
/*!**********************************!*\
  !*** ./node_modules/lit/html.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttributeCommitter": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.AttributeCommitter),
/* harmony export */   "AttributePart": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.AttributePart),
/* harmony export */   "BooleanAttributePart": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.BooleanAttributePart),
/* harmony export */   "DefaultTemplateProcessor": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.DefaultTemplateProcessor),
/* harmony export */   "EventPart": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.EventPart),
/* harmony export */   "NodePart": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.NodePart),
/* harmony export */   "PropertyCommitter": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.PropertyCommitter),
/* harmony export */   "PropertyPart": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.PropertyPart),
/* harmony export */   "SVGTemplateResult": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.SVGTemplateResult),
/* harmony export */   "Template": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.Template),
/* harmony export */   "TemplateInstance": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.TemplateInstance),
/* harmony export */   "TemplateResult": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.TemplateResult),
/* harmony export */   "createMarker": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.createMarker),
/* harmony export */   "defaultTemplateProcessor": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.defaultTemplateProcessor),
/* harmony export */   "directive": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.directive),
/* harmony export */   "html": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.html),
/* harmony export */   "isDirective": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.isDirective),
/* harmony export */   "isIterable": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.isIterable),
/* harmony export */   "isPrimitive": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.isPrimitive),
/* harmony export */   "isTemplatePartActive": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.isTemplatePartActive),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.noChange),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.nothing),
/* harmony export */   "parts": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.parts),
/* harmony export */   "removeNodes": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.removeNodes),
/* harmony export */   "render": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "reparentNodes": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.reparentNodes),
/* harmony export */   "svg": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.svg),
/* harmony export */   "templateCaches": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.templateCaches),
/* harmony export */   "templateFactory": () => (/* reexport safe */ lit_html__WEBPACK_IMPORTED_MODULE_0__.templateFactory)
/* harmony export */ });
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/lit-html.js");


/***/ })

}]);
//# sourceMappingURL=search-deepdive-9.1.7.min.js.map